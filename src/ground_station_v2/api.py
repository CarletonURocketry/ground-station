from fastapi import FastAPI, Header, WebSocket, WebSocketException, WebSocketDisconnect, HTTPException
import uuid
import uvicorn
import asyncio
from src.ground_station_v2.replay import Replay
import logging
from src.ground_station_v2.record import Record

logger = logging.getLogger(__name__)

app = FastAPI()

connected_clients: dict[str, WebSocket] = {}

# generates a uuid for the client to use 
@app.get("/client_id")
async def get_client_id():
    client_id = str(uuid.uuid4())
    return {"client_id": client_id}

# all the requests below expect the X-Client-ID header to be set with the client_id from the request above 
# for now it's not checked whether it was generated by the get_client_id endpoint or not, this will be changed 

# TODO: include the header id check in middleware

@app.post("/replay_play")
async def replay_play(x_client_id: str = Header(alias="X-Client-ID")):
    if x_client_id not in connected_clients:
        raise HTTPException(status_code=401, detail="Client not connected")
    
    logger.info(f"Replay played for client {x_client_id}")

    return {"status": "ok"}

@app.post("/replay_pause")
async def replay_pause(x_client_id: str = Header(alias="X-Client-ID")):
    if x_client_id not in connected_clients:
        raise HTTPException(status_code=401, detail="Client not connected")

    logger.info(f"Replay paused for client {x_client_id}")
    return {"status": "ok"}

@app.post("/replay_goto")
async def replay_goto(x_client_id: str = Header(alias="X-Client-ID")):
    if x_client_id not in connected_clients:
        raise HTTPException(status_code=401, detail="Client not connected")

    logger.info(f"Replay goto for client {x_client_id}")

    return {"status": "ok"}

@app.post("/record_start")
async def record_start(x_client_id: str = Header(alias="X-Client-ID")):

    logger.info(f"Record start for client {x_client_id}")
    return {"status": "ok"}

@app.post("/record_stop")
async def record_stop(x_client_id: str = Header(alias="X-Client-ID")):

    logger.info(f"Record stop for client {x_client_id}")
    return {"status": "ok"}

# simple readonly websocket endpoint, doesn't process any commands 
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket, x_client_id: str = Header(alias="X-Client-ID")):
    if x_client_id in connected_clients:
        logger.warning(f"Client already connected: {x_client_id}")
        raise WebSocketException(code=1008, reason="Client already connected")

    await websocket.accept()
    connected_clients[x_client_id] = websocket
    logger.info(f"Client connected: {x_client_id}")

    try:
        # stal the socket, we can now reuse the websocket object from other func so send data to the client
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        connected_clients.pop(x_client_id, None)
        logger.info(f"Client disconnected: {x_client_id}")

def run_server(host: str = "0.0.0.0", port: int = 8000):
    uvicorn.run(app, host=host, port=port)