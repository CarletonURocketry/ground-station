from fastapi import FastAPI, Header, WebSocket, WebSocketException, WebSocketDisconnect, HTTPException
from contextlib import asynccontextmanager
import uuid
import uvicorn
import asyncio
import json
from src.ground_station_v2.replay import Replay
from src.ground_station_v2.record import Record
from typing import Any
import logging
from src.ground_station_v2.radio.serial import get_radio_packet
from src.ground_station_v2.radio.packets.spec import parse_rn2483_transmission
from src.ground_station_v2.config import load_config

logger = logging.getLogger(__name__)

recorder = Record()

connected_clients: dict[str, WebSocket] = {}

async def broadcast_radio_packets():
    logger.info("Starting broadcast_radio_packets")
    config = load_config("config.json")

    try:
        logger.info("STARTING TRY")
        recorder.init_mission("recordings", "test_mission")
        recorder.start()

        async for packet in get_radio_packet(True):
            packet_hex = packet.hex()
            parsed = parse_rn2483_transmission(packet_hex, config)

            if (recorder.recording):
                logger.info("Writing")
                recorder.write(packet_hex, parsed)
            
            if not parsed:
                logger.warning(f"Failed to parse packet: {packet_hex}")
                continue
            
            telemetry_dict: dict[str, Any] = {}
            for block in parsed.blocks:
                block.output_formatted(telemetry_dict)
            
            json_packet: str = json.dumps(telemetry_dict)
            
            disconnected: list[str] = []
            for client_id, websocket in connected_clients.items():
                try:
                    await websocket.send_text(json_packet)
                except Exception as e:
                    logger.warning(f"Failed to send to client {client_id}: {e}")
                    disconnected.append(client_id)
            
            for client_id in disconnected:
                connected_clients.pop(client_id, None)

        recorder.stop()
        recorder.close_mission()
    except Exception as e:
        recorder.stop()
        recorder.close_mission()
        logger.error(f"Error in broadcast_radio_packets: {e}", exc_info=True)
        


# handles the lifespan of the app, creates and destroys async tasks
@asynccontextmanager
async def lifespan(app: FastAPI):
    task = asyncio.create_task(broadcast_radio_packets())
    yield
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        pass

app = FastAPI(lifespan=lifespan)


# generates a uuid for the client to use 
@app.get("/client_id")
async def get_client_id():
    client_id = str(uuid.uuid4())
    return {"client_id": client_id}

# all the requests below expect the X-Client-ID header to be set with the client_id from the request above 
# for now it's not checked whether it was generated by the get_client_id endpoint or not, this will be changed 

# TODO: include the header id check in middleware

@app.post("/replay_play")
async def replay_play(x_client_id: str = Header(alias="X-Client-ID")):
    if x_client_id not in connected_clients:
        raise HTTPException(status_code=401, detail="Client not connected")
    
    logger.info(f"Replay played for client {x_client_id}")

    return {"status": "ok"}

@app.post("/replay_pause")
async def replay_pause(x_client_id: str = Header(alias="X-Client-ID")):
    if x_client_id not in connected_clients:
        raise HTTPException(status_code=401, detail="Client not connected")

    logger.info(f"Replay paused for client {x_client_id}")
    return {"status": "ok"}

@app.post("/replay_goto")
async def replay_goto(x_client_id: str = Header(alias="X-Client-ID")):
    if x_client_id not in connected_clients:
        raise HTTPException(status_code=401, detail="Client not connected")

    logger.info(f"Replay goto for client {x_client_id}")

    return {"status": "ok"}

@app.post("/record_start")
async def record_start(x_client_id: str = Header(alias="X-Client-ID")):

    recorder.start()
    logger.info(f"Record start for client {x_client_id}")
    return {"status": "ok"}

@app.post("/record_stop")
async def record_stop(x_client_id: str = Header(alias="X-Client-ID")):

    recorder.stop()
    logger.info(f"Record stop for client {x_client_id}")
    return {"status": "ok"}

# simple readonly websocket endpoint, doesn't process any commands 
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket, x_client_id: str = Header(alias="X-Client-ID")):
    if x_client_id in connected_clients:
        logger.warning(f"Client already connected: {x_client_id}")
        raise WebSocketException(code=1008, reason="Client already connected")

    await websocket.accept()
    connected_clients[x_client_id] = websocket
    logger.info(f"Client connected: {x_client_id}")

    try:
        # stal the socket, we can now reuse the websocket object from other func so send data to the client
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        connected_clients.pop(x_client_id, None)
        logger.info(f"Client disconnected: {x_client_id}")

def run_server(host: str = "0.0.0.0", port: int = 8000):
    uvicorn.run(app, host=host, port=port)